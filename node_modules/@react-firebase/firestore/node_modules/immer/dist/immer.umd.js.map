{"version":3,"file":"immer.umd.js","sources":["../src/common.js","../src/es5.js","../src/proxy.js","../src/patches.js","../src/immer.js","../src/index.js"],"sourcesContent":["export const NOTHING =\n    typeof Symbol !== \"undefined\"\n        ? Symbol(\"immer-nothing\")\n        : {[\"immer-nothing\"]: true}\n\nexport const DRAFTABLE =\n    typeof Symbol !== \"undefined\"\n        ? Symbol(\"immer-draftable\")\n        : \"__$immer_draftable\"\n\nexport const DRAFT_STATE =\n    typeof Symbol !== \"undefined\" ? Symbol(\"immer-state\") : \"__$immer_state\"\n\nexport function isDraft(value) {\n    return !!value && !!value[DRAFT_STATE]\n}\n\nexport function isDraftable(value) {\n    if (!value || typeof value !== \"object\") return false\n    if (Array.isArray(value)) return true\n    const proto = Object.getPrototypeOf(value)\n    if (!proto || proto === Object.prototype) return true\n    return !!value[DRAFTABLE] || !!value.constructor[DRAFTABLE]\n}\n\nexport function original(value) {\n    if (value && value[DRAFT_STATE]) {\n        return value[DRAFT_STATE].base\n    }\n    // otherwise return undefined\n}\n\nexport const assign =\n    Object.assign ||\n    function assign(target, value) {\n        for (let key in value) {\n            if (has(value, key)) {\n                target[key] = value[key]\n            }\n        }\n        return target\n    }\n\nexport const ownKeys =\n    typeof Reflect !== \"undefined\" && Reflect.ownKeys\n        ? Reflect.ownKeys\n        : typeof Object.getOwnPropertySymbols !== \"undefined\"\n        ? obj =>\n              Object.getOwnPropertyNames(obj).concat(\n                  Object.getOwnPropertySymbols(obj)\n              )\n        : Object.getOwnPropertyNames\n\nexport function shallowCopy(base, invokeGetters = false) {\n    if (Array.isArray(base)) return base.slice()\n    const clone = Object.create(Object.getPrototypeOf(base))\n    ownKeys(base).forEach(key => {\n        if (key === DRAFT_STATE) {\n            return // Never copy over draft state.\n        }\n        const desc = Object.getOwnPropertyDescriptor(base, key)\n        if (desc.get) {\n            if (!invokeGetters) {\n                throw new Error(\"Immer drafts cannot have computed properties\")\n            }\n            desc.value = desc.get.call(base)\n        }\n        if (desc.enumerable) {\n            clone[key] = desc.value\n        } else {\n            Object.defineProperty(clone, key, {\n                value: desc.value,\n                writable: true,\n                configurable: true\n            })\n        }\n    })\n    return clone\n}\n\nexport function each(value, cb) {\n    if (Array.isArray(value)) {\n        for (let i = 0; i < value.length; i++) cb(i, value[i], value)\n    } else {\n        ownKeys(value).forEach(key => cb(key, value[key], value))\n    }\n}\n\nexport function isEnumerable(base, prop) {\n    return Object.getOwnPropertyDescriptor(base, prop).enumerable\n}\n\nexport function has(thing, prop) {\n    return Object.prototype.hasOwnProperty.call(thing, prop)\n}\n\nexport function is(x, y) {\n    // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n    if (x === y) {\n        return x !== 0 || 1 / x === 1 / y\n    } else {\n        return x !== x && y !== y\n    }\n}\n","\"use strict\"\n// @ts-check\n\nimport {\n    each,\n    has,\n    is,\n    isDraft,\n    isDraftable,\n    isEnumerable,\n    shallowCopy,\n    DRAFT_STATE\n} from \"./common\"\n\nconst descriptors = {}\n\n// For nested produce calls:\nexport const scopes = []\nexport const currentScope = () => scopes[scopes.length - 1]\n\nexport function willFinalize(result, baseDraft, needPatches) {\n    const scope = currentScope()\n    scope.forEach(state => (state.finalizing = true))\n    if (result === undefined || result === baseDraft) {\n        if (needPatches) markChangesRecursively(baseDraft)\n        // This is faster when we don't care about which attributes changed.\n        markChangesSweep(scope)\n    }\n}\n\nexport function createDraft(base, parent) {\n    const isArray = Array.isArray(base)\n    const draft = clonePotentialDraft(base)\n    each(draft, prop => {\n        proxyProperty(draft, prop, isArray || isEnumerable(base, prop))\n    })\n\n    // See \"proxy.js\" for property documentation.\n    const state = {\n        scope: parent ? parent.scope : currentScope(),\n        modified: false,\n        finalizing: false, // es5 only\n        finalized: false,\n        assigned: {},\n        parent,\n        base,\n        draft,\n        copy: null,\n        revoke,\n        revoked: false // es5 only\n    }\n\n    createHiddenProperty(draft, DRAFT_STATE, state)\n    state.scope.push(state)\n    return draft\n}\n\nfunction revoke() {\n    this.revoked = true\n}\n\nfunction source(state) {\n    return state.copy || state.base\n}\n\nfunction get(state, prop) {\n    assertUnrevoked(state)\n    const value = source(state)[prop]\n    // Drafts are only created for proxyable values that exist in the base state.\n    if (!state.finalizing && value === state.base[prop] && isDraftable(value)) {\n        prepareCopy(state)\n        return (state.copy[prop] = createDraft(value, state))\n    }\n    return value\n}\n\nfunction set(state, prop, value) {\n    assertUnrevoked(state)\n    state.assigned[prop] = true\n    if (!state.modified) {\n        if (is(source(state)[prop], value)) return\n        markChanged(state)\n        prepareCopy(state)\n    }\n    state.copy[prop] = value\n}\n\nfunction markChanged(state) {\n    if (!state.modified) {\n        state.modified = true\n        if (state.parent) markChanged(state.parent)\n    }\n}\n\nfunction prepareCopy(state) {\n    if (!state.copy) state.copy = clonePotentialDraft(state.base)\n}\n\nfunction clonePotentialDraft(base) {\n    const state = base && base[DRAFT_STATE]\n    if (state) {\n        state.finalizing = true\n        const draft = shallowCopy(state.draft, true)\n        state.finalizing = false\n        return draft\n    }\n    return shallowCopy(base)\n}\n\nfunction proxyProperty(draft, prop, enumerable) {\n    let desc = descriptors[prop]\n    if (desc) {\n        desc.enumerable = enumerable\n    } else {\n        descriptors[prop] = desc = {\n            configurable: true,\n            enumerable,\n            get() {\n                return get(this[DRAFT_STATE], prop)\n            },\n            set(value) {\n                set(this[DRAFT_STATE], prop, value)\n            }\n        }\n    }\n    Object.defineProperty(draft, prop, desc)\n}\n\nfunction assertUnrevoked(state) {\n    if (state.revoked === true)\n        throw new Error(\n            \"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" +\n                JSON.stringify(source(state))\n        )\n}\n\n// This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\nfunction markChangesSweep(scope) {\n    // The natural order of drafts in the `scope` array is based on when they\n    // were accessed. By processing drafts in reverse natural order, we have a\n    // better chance of processing leaf nodes first. When a leaf node is known to\n    // have changed, we can avoid any traversal of its ancestor nodes.\n    for (let i = scope.length - 1; i >= 0; i--) {\n        const state = scope[i]\n        if (state.modified === false) {\n            if (Array.isArray(state.base)) {\n                if (hasArrayChanges(state)) markChanged(state)\n            } else if (hasObjectChanges(state)) markChanged(state)\n        }\n    }\n}\n\nfunction markChangesRecursively(object) {\n    if (!object || typeof object !== \"object\") return\n    const state = object[DRAFT_STATE]\n    if (!state) return\n    const {base, draft, assigned} = state\n    if (!Array.isArray(object)) {\n        // Look for added keys.\n        Object.keys(draft).forEach(key => {\n            // The `undefined` check is a fast path for pre-existing keys.\n            if (base[key] === undefined && !has(base, key)) {\n                assigned[key] = true\n                markChanged(state)\n            } else if (!assigned[key]) {\n                // Only untouched properties trigger recursion.\n                markChangesRecursively(draft[key])\n            }\n        })\n        // Look for removed keys.\n        Object.keys(base).forEach(key => {\n            // The `undefined` check is a fast path for pre-existing keys.\n            if (draft[key] === undefined && !has(draft, key)) {\n                assigned[key] = false\n                markChanged(state)\n            }\n        })\n    } else if (hasArrayChanges(state)) {\n        markChanged(state)\n        assigned.length = true\n        if (draft.length < base.length) {\n            for (let i = draft.length; i < base.length; i++) assigned[i] = false\n        } else {\n            for (let i = base.length; i < draft.length; i++) assigned[i] = true\n        }\n        for (let i = 0; i < draft.length; i++) {\n            // Only untouched indices trigger recursion.\n            if (assigned[i] === undefined) markChangesRecursively(draft[i])\n        }\n    }\n}\n\nfunction hasObjectChanges(state) {\n    const {base, draft} = state\n\n    // Search for added keys. Start at the back, because non-numeric keys\n    // are ordered by time of definition on the object.\n    const keys = Object.keys(draft)\n    for (let i = keys.length - 1; i >= 0; i--) {\n        // The `undefined` check is a fast path for pre-existing keys.\n        if (base[keys[i]] === undefined && !has(base, keys[i])) {\n            return true\n        }\n    }\n\n    // Since no keys have been added, we can compare lengths to know if an\n    // object has been deleted.\n    return keys.length !== Object.keys(base).length\n}\n\nfunction hasArrayChanges(state) {\n    const {draft} = state\n    if (draft.length !== state.base.length) return true\n    // See #116\n    // If we first shorten the length, our array interceptors will be removed.\n    // If after that new items are added, result in the same original length,\n    // those last items will have no intercepting property.\n    // So if there is no own descriptor on the last position, we know that items were removed and added\n    // N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\n    // the last one\n    const descriptor = Object.getOwnPropertyDescriptor(draft, draft.length - 1)\n    // descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\n    if (descriptor && !descriptor.get) return true\n    // For all other cases, we don't have to compare, as they would have been picked up by the index setters\n    return false\n}\n\nfunction createHiddenProperty(target, prop, value) {\n    Object.defineProperty(target, prop, {\n        value: value,\n        enumerable: false,\n        writable: true\n    })\n}\n","\"use strict\"\n// @ts-check\n\nimport {\n    assign,\n    each,\n    has,\n    is,\n    isDraftable,\n    isDraft,\n    shallowCopy,\n    DRAFT_STATE\n} from \"./common\"\n\n// For nested produce calls:\nexport const scopes = []\nexport const currentScope = () => scopes[scopes.length - 1]\n\n// Do nothing before being finalized.\nexport function willFinalize() {}\n\nexport function createDraft(base, parent) {\n    const state = {\n        // Track which produce call this is associated with.\n        scope: parent ? parent.scope : currentScope(),\n        // True for both shallow and deep changes.\n        modified: false,\n        // Used during finalization.\n        finalized: false,\n        // Track which properties have been assigned (true) or deleted (false).\n        assigned: {},\n        // The parent draft state.\n        parent,\n        // The base state.\n        base,\n        // The base proxy.\n        draft: null,\n        // Any property proxies.\n        drafts: {},\n        // The base copy with any updated values.\n        copy: null,\n        // Called by the `produce` function.\n        revoke: null\n    }\n\n    const {revoke, proxy} = Array.isArray(base)\n        ? Proxy.revocable([state], arrayTraps)\n        : Proxy.revocable(state, objectTraps)\n\n    state.draft = proxy\n    state.revoke = revoke\n\n    state.scope.push(state)\n    return proxy\n}\n\nconst objectTraps = {\n    get,\n    has(target, prop) {\n        return prop in source(target)\n    },\n    ownKeys(target) {\n        return Reflect.ownKeys(source(target))\n    },\n    set,\n    deleteProperty,\n    getOwnPropertyDescriptor,\n    defineProperty() {\n        throw new Error(\"Object.defineProperty() cannot be used on an Immer draft\") // prettier-ignore\n    },\n    getPrototypeOf(target) {\n        return Object.getPrototypeOf(target.base)\n    },\n    setPrototypeOf() {\n        throw new Error(\"Object.setPrototypeOf() cannot be used on an Immer draft\") // prettier-ignore\n    }\n}\n\nconst arrayTraps = {}\neach(objectTraps, (key, fn) => {\n    arrayTraps[key] = function() {\n        arguments[0] = arguments[0][0]\n        return fn.apply(this, arguments)\n    }\n})\narrayTraps.deleteProperty = function(state, prop) {\n    if (isNaN(parseInt(prop))) {\n        throw new Error(\"Immer only supports deleting array indices\") // prettier-ignore\n    }\n    return objectTraps.deleteProperty.call(this, state[0], prop)\n}\narrayTraps.set = function(state, prop, value) {\n    if (prop !== \"length\" && isNaN(parseInt(prop))) {\n        throw new Error(\"Immer only supports setting array indices and the 'length' property\") // prettier-ignore\n    }\n    return objectTraps.set.call(this, state[0], prop, value)\n}\n\nfunction source(state) {\n    return state.copy || state.base\n}\n\nfunction get(state, prop) {\n    if (prop === DRAFT_STATE) return state\n    let {drafts} = state\n\n    // Check for existing draft in unmodified state.\n    if (!state.modified && has(drafts, prop)) {\n        return drafts[prop]\n    }\n\n    const value = source(state)[prop]\n    if (state.finalized || !isDraftable(value)) return value\n\n    // Check for existing draft in modified state.\n    if (state.modified) {\n        // Assigned values are never drafted. This catches any drafts we created, too.\n        if (value !== state.base[prop]) return value\n        // Store drafts on the copy (when one exists).\n        drafts = state.copy\n    }\n\n    return (drafts[prop] = createDraft(value, state))\n}\n\nfunction set(state, prop, value) {\n    if (!state.modified) {\n        // Optimize based on value's truthiness. Truthy values are guaranteed to\n        // never be undefined, so we can avoid the `in` operator. Lastly, truthy\n        // values may be drafts, but falsy values are never drafts.\n        const isUnchanged = value\n            ? is(state.base[prop], value) || value === state.drafts[prop]\n            : is(state.base[prop], value) && prop in state.base\n        if (isUnchanged) return true\n        markChanged(state)\n    }\n    state.assigned[prop] = true\n    state.copy[prop] = value\n    return true\n}\n\nfunction deleteProperty(state, prop) {\n    // The `undefined` check is a fast path for pre-existing keys.\n    if (state.base[prop] !== undefined || prop in state.base) {\n        state.assigned[prop] = false\n        markChanged(state)\n    }\n    if (state.copy) delete state.copy[prop]\n    return true\n}\n\nfunction getOwnPropertyDescriptor(state, prop) {\n    const owner = source(state)\n    const desc = Reflect.getOwnPropertyDescriptor(owner, prop)\n    if (desc) {\n        desc.writable = true\n        desc.configurable = !Array.isArray(owner) || prop !== \"length\"\n    }\n    return desc\n}\n\nfunction markChanged(state) {\n    if (!state.modified) {\n        state.modified = true\n        state.copy = assign(shallowCopy(state.base), state.drafts)\n        state.drafts = null\n        if (state.parent) markChanged(state.parent)\n    }\n}\n","import {each} from \"./common\"\n\nexport function generatePatches(state, basePath, patches, inversePatches) {\n    Array.isArray(state.base)\n        ? generateArrayPatches(state, basePath, patches, inversePatches)\n        : generateObjectPatches(state, basePath, patches, inversePatches)\n}\n\nfunction generateArrayPatches(state, basePath, patches, inversePatches) {\n    const {base, copy, assigned} = state\n    const minLength = Math.min(base.length, copy.length)\n\n    // Look for replaced indices.\n    for (let i = 0; i < minLength; i++) {\n        if (assigned[i] && base[i] !== copy[i]) {\n            const path = basePath.concat(i)\n            patches.push({op: \"replace\", path, value: copy[i]})\n            inversePatches.push({op: \"replace\", path, value: base[i]})\n        }\n    }\n\n    // Did the array expand?\n    if (minLength < copy.length) {\n        for (let i = minLength; i < copy.length; i++) {\n            patches.push({\n                op: \"add\",\n                path: basePath.concat(i),\n                value: copy[i]\n            })\n        }\n        inversePatches.push({\n            op: \"replace\",\n            path: basePath.concat(\"length\"),\n            value: base.length\n        })\n    }\n\n    // ...or did it shrink?\n    else if (minLength < base.length) {\n        patches.push({\n            op: \"replace\",\n            path: basePath.concat(\"length\"),\n            value: copy.length\n        })\n        for (let i = minLength; i < base.length; i++) {\n            inversePatches.push({\n                op: \"add\",\n                path: basePath.concat(i),\n                value: base[i]\n            })\n        }\n    }\n}\n\nfunction generateObjectPatches(state, basePath, patches, inversePatches) {\n    const {base, copy} = state\n    each(state.assigned, (key, assignedValue) => {\n        const origValue = base[key]\n        const value = copy[key]\n        const op = !assignedValue ? \"remove\" : key in base ? \"replace\" : \"add\"\n        if (origValue === value && op === \"replace\") return\n        const path = basePath.concat(key)\n        patches.push(op === \"remove\" ? {op, path} : {op, path, value})\n        inversePatches.push(\n            op === \"add\"\n                ? {op: \"remove\", path}\n                : op === \"remove\"\n                ? {op: \"add\", path, value: origValue}\n                : {op: \"replace\", path, value: origValue}\n        )\n    })\n}\n\nexport function applyPatches(draft, patches) {\n    for (let i = 0; i < patches.length; i++) {\n        const patch = patches[i]\n        const {path} = patch\n        if (path.length === 0 && patch.op === \"replace\") {\n            draft = patch.value\n        } else {\n            let base = draft\n            for (let i = 0; i < path.length - 1; i++) {\n                base = base[path[i]]\n                if (!base || typeof base !== \"object\")\n                    throw new Error(\"Cannot apply patch, path doesn't resolve: \" + path.join(\"/\")) // prettier-ignore\n            }\n            const key = path[path.length - 1]\n            switch (patch.op) {\n                case \"replace\":\n                case \"add\":\n                    // TODO: add support is not extensive, it does not support insertion or `-` atm!\n                    base[key] = patch.value\n                    break\n                case \"remove\":\n                    if (Array.isArray(base)) {\n                        if (key !== base.length - 1)\n                            throw new Error(`Only the last index of an array can be removed, index: ${key}, length: ${base.length}`) // prettier-ignore\n                        base.length -= 1\n                    } else {\n                        delete base[key]\n                    }\n                    break\n                default:\n                    throw new Error(\"Unsupported patch operation: \" + patch.op)\n            }\n        }\n    }\n    return draft\n}\n","import * as legacyProxy from \"./es5\"\nimport * as modernProxy from \"./proxy\"\nimport {applyPatches, generatePatches} from \"./patches\"\nimport {\n    assign,\n    each,\n    has,\n    is,\n    isDraft,\n    isDraftable,\n    isEnumerable,\n    shallowCopy,\n    DRAFT_STATE,\n    NOTHING\n} from \"./common\"\n\nfunction verifyMinified() {}\n\nconst configDefaults = {\n    useProxies: typeof Proxy !== \"undefined\" && typeof Reflect !== \"undefined\",\n    autoFreeze:\n        typeof process !== \"undefined\"\n            ? process.env.NODE_ENV !== \"production\"\n            : verifyMinified.name === \"verifyMinified\",\n    onAssign: null,\n    onDelete: null,\n    onCopy: null\n}\n\nexport class Immer {\n    constructor(config) {\n        assign(this, configDefaults, config)\n        this.setUseProxies(this.useProxies)\n        this.produce = this.produce.bind(this)\n    }\n    produce(base, recipe, patchListener) {\n        // curried invocation\n        if (typeof base === \"function\" && typeof recipe !== \"function\") {\n            const defaultBase = recipe\n            recipe = base\n\n            // prettier-ignore\n            return (base = defaultBase, ...args) =>\n                this.produce(base, draft => recipe.call(draft, draft, ...args))\n        }\n\n        // prettier-ignore\n        {\n            if (typeof recipe !== \"function\") throw new Error(\"if first argument is not a function, the second argument to produce should be a function\")\n            if (patchListener !== undefined && typeof patchListener !== \"function\") throw new Error(\"the third argument of a producer should not be set or a function\")\n        }\n\n        let result\n        // Only create proxies for plain objects/arrays.\n        if (!isDraftable(base)) {\n            result = recipe(base)\n            if (result === undefined) return base\n        }\n        // The given value must be proxied.\n        else {\n            this.scopes.push([])\n            const baseDraft = this.createDraft(base)\n            try {\n                result = recipe.call(baseDraft, baseDraft)\n                this.willFinalize(result, baseDraft, !!patchListener)\n\n                // Never generate patches when no listener exists.\n                var patches = patchListener && [],\n                    inversePatches = patchListener && []\n\n                // Finalize the modified draft...\n                if (result === undefined || result === baseDraft) {\n                    result = this.finalize(\n                        baseDraft,\n                        [],\n                        patches,\n                        inversePatches\n                    )\n                }\n                // ...or use a replacement value.\n                else {\n                    // Users must never modify the draft _and_ return something else.\n                    if (baseDraft[DRAFT_STATE].modified)\n                        throw new Error(\"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\") // prettier-ignore\n\n                    // Finalize the replacement in case it contains (or is) a subset of the draft.\n                    if (isDraftable(result)) result = this.finalize(result)\n\n                    if (patchListener) {\n                        patches.push({\n                            op: \"replace\",\n                            path: [],\n                            value: result\n                        })\n                        inversePatches.push({\n                            op: \"replace\",\n                            path: [],\n                            value: base\n                        })\n                    }\n                }\n            } finally {\n                this.currentScope().forEach(state => state.revoke())\n                this.scopes.pop()\n            }\n            patchListener && patchListener(patches, inversePatches)\n        }\n        // Normalize the result.\n        return result === NOTHING ? undefined : result\n    }\n    setAutoFreeze(value) {\n        this.autoFreeze = value\n    }\n    setUseProxies(value) {\n        this.useProxies = value\n        assign(this, value ? modernProxy : legacyProxy)\n    }\n    applyPatches(base, patches) {\n        // Mutate the base state when a draft is passed.\n        if (isDraft(base)) {\n            return applyPatches(base, patches)\n        }\n        // Otherwise, produce a copy of the base state.\n        return this.produce(base, draft => applyPatches(draft, patches))\n    }\n    /**\n     * @internal\n     * Finalize a draft, returning either the unmodified base state or a modified\n     * copy of the base state.\n     */\n    finalize(draft, path, patches, inversePatches) {\n        const state = draft[DRAFT_STATE]\n        if (!state) {\n            if (Object.isFrozen(draft)) return draft\n            return this.finalizeTree(draft)\n        }\n        // Never finalize drafts owned by an outer scope.\n        if (state.scope !== this.currentScope()) {\n            return draft\n        }\n        if (!state.modified) return state.base\n        if (!state.finalized) {\n            state.finalized = true\n            this.finalizeTree(state.draft, path, patches, inversePatches)\n            if (this.onDelete) {\n                // The `assigned` object is unreliable with ES5 drafts.\n                if (this.useProxies) {\n                    const {assigned} = state\n                    for (const prop in assigned) {\n                        if (!assigned[prop]) this.onDelete(state, prop)\n                    }\n                } else {\n                    const {base, copy} = state\n                    each(base, prop => {\n                        if (!has(copy, prop)) this.onDelete(state, prop)\n                    })\n                }\n            }\n            if (this.onCopy) this.onCopy(state)\n\n            // Nested producers must never auto-freeze their result,\n            // because it may contain drafts from parent producers.\n            if (this.autoFreeze && this.scopes.length === 1) {\n                Object.freeze(state.copy)\n            }\n\n            if (patches) generatePatches(state, path, patches, inversePatches)\n        }\n        return state.copy\n    }\n    /**\n     * @internal\n     * Finalize all drafts in the given state tree.\n     */\n    finalizeTree(root, path, patches, inversePatches) {\n        const state = root[DRAFT_STATE]\n        if (state) {\n            if (!this.useProxies) {\n                state.finalizing = true\n                state.copy = shallowCopy(state.draft, true)\n                state.finalizing = false\n            }\n            root = state.copy\n        }\n\n        const {onAssign} = this\n        const finalizeProperty = (prop, value, parent) => {\n            if (value === parent) {\n                throw Error(\"Immer forbids circular references\")\n            }\n\n            // The only possible draft (in the scope of a `finalizeTree` call) is the `root` object.\n            const inDraft = !!state && parent === root\n\n            if (isDraft(value)) {\n                value =\n                    // Patches are never generated for assigned properties.\n                    patches && inDraft && !state.assigned[prop]\n                        ? this.finalize(value, path.concat(prop), patches, inversePatches) // prettier-ignore\n                        : this.finalize(value)\n\n                // Preserve non-enumerable properties.\n                if (Array.isArray(parent) || isEnumerable(parent, prop)) {\n                    parent[prop] = value\n                } else {\n                    Object.defineProperty(parent, prop, {value})\n                }\n\n                // Unchanged drafts are never passed to the `onAssign` hook.\n                if (inDraft && value === state.base[prop]) return\n            }\n            // Unchanged draft properties are ignored.\n            else if (inDraft && is(value, state.base[prop])) {\n                return\n            }\n            // Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n            else if (isDraftable(value) && !Object.isFrozen(value)) {\n                each(value, finalizeProperty)\n            }\n\n            if (inDraft && onAssign) {\n                onAssign(state, prop, value)\n            }\n        }\n\n        each(root, finalizeProperty)\n        return root\n    }\n}\n","import {Immer} from \"./immer\"\n\nconst immer = new Immer()\n\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\nexport const produce = immer.produce\nexport default produce\n\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * By default, auto-freezing is disabled in production.\n */\nexport const setAutoFreeze = immer.setAutoFreeze.bind(immer)\n\n/**\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n * always faster than using ES5 proxies.\n *\n * By default, feature detection is used, so calling this is rarely necessary.\n */\nexport const setUseProxies = immer.setUseProxies.bind(immer)\n\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\nexport const applyPatches = immer.applyPatches.bind(immer)\n\nexport {\n    original,\n    isDraft,\n    isDraftable,\n    NOTHING as nothing,\n    DRAFTABLE as immerable\n} from \"./common\"\n\nexport {Immer}\n"],"names":["NOTHING","Symbol","DRAFTABLE","DRAFT_STATE","isDraft","value","isDraftable","Array","isArray","proto","Object","getPrototypeOf","prototype","constructor","assign","target","key","has","ownKeys","Reflect","getOwnPropertySymbols","getOwnPropertyNames","obj","concat","shallowCopy","base","invokeGetters","slice","clone","create","forEach","desc","getOwnPropertyDescriptor","get","Error","call","enumerable","defineProperty","each","cb","i","length","isEnumerable","prop","thing","hasOwnProperty","is","x","y","descriptors","scopes","currentScope","createDraft","parent","draft","clonePotentialDraft","state","source","finalizing","copy","this","assigned","modified","scope","push","revoke","revoked","markChanged","prepareCopy","assertUnrevoked","JSON","stringify","hasObjectChanges","keys","undefined","hasArrayChanges","descriptor","result","baseDraft","needPatches","markChangesRecursively","object","Proxy","revocable","arrayTraps","objectTraps","proxy","drafts","finalized","isUnchanged","owner","writable","configurable","fn","arguments","apply","deleteProperty","isNaN","parseInt","set","generatePatches","basePath","patches","inversePatches","minLength","Math","min","path","op","generateArrayPatches","assignedValue","origValue","generateObjectPatches","applyPatches","patch","join","configDefaults","process","env","NODE_ENV","name","Immer","config","setUseProxies","useProxies","produce","bind","recipe","patchListener","defaultBase","args","_this","willFinalize","finalize","pop","autoFreeze","modernProxy","legacyProxy","isFrozen","finalizeTree","onDelete","_this2","onCopy","freeze","root","onAssign","finalizeProperty","inDraft","_this3","immer","setAutoFreeze"],"mappings":"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"}